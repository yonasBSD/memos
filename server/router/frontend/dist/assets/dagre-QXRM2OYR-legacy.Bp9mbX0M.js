System.register(["./mermaid-vendor-legacy.CXJ3QjYr.js","./graph-legacy.FlF_t-Ri.js","./layout-legacy.BBfE06kv.js","./utils-vendor-legacy.4FVC2SsJ.js","./react-vendor-legacy.dIDhV_HT.js"],(function(e,n){"use strict";var t,r,a,i,o,d,s,c,g,l,f,h,u,p,w,v,y,m,X,E,N;return{setters:[e=>{t=e._,r=e.ah,a=e.ai,i=e.aj,o=e.ak,d=e.l,s=e.c,c=e.al,g=e.am,l=e.a8,f=e.ad,h=e.a9,u=e.a7,p=e.an,w=e.ao,v=e.ap},e=>{y=e.G},e=>{m=e.l},e=>{X=e.g,E=e.j,N=e.n},null],execute:function(){function n(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:b(e),edges:C(e)};return X(e.graph())||(n.value=E(e.graph())),n}function b(e){return N(e.nodes(),(function(n){var t=e.node(n),r=e.parent(n),a={v:n};return X(t)||(a.value=t),X(r)||(a.parent=r),a}))}function C(e){return N(e.edges(),(function(n){var t=e.edge(n),r={v:n.v,w:n.w};return X(n.name)||(r.name=n.name),X(t)||(r.value=t),r}))}var S=new Map,x=new Map,I=new Map,D=t((()=>{x.clear(),I.clear(),S.clear()}),"clear"),O=t(((e,n)=>{const t=x.get(n)||[];return d.trace("In isDescendant",n," ",e," = ",t.includes(e)),t.includes(e)}),"isDescendant"),k=t(((e,n)=>{const t=x.get(n)||[];return d.info("Descendants of ",n," is ",t),d.info("Edge is ",e),e.v!==n&&e.w!==n&&(t?t.includes(e.v)||O(e.v,n)||O(e.w,n)||t.includes(e.w):(d.debug("Tilt, ",n,",not in descendants"),!1))}),"edgeInCluster"),G=t(((e,n,t,r)=>{d.warn("Copying children of ",e,"root",r,"data",n.node(e),r);const a=n.children(e)||[];e!==r&&a.push(e),d.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach((a=>{if(n.children(a).length>0)G(a,n,t,r);else{const i=n.node(a);d.info("cp ",a," to ",r," with parent ",e),t.setNode(a,i),r!==n.parent(a)&&(d.warn("Setting parent",a,n.parent(a)),t.setParent(a,n.parent(a))),e!==r&&a!==e?(d.debug("Setting parent",a,e),t.setParent(a,e)):(d.info("In copy ",e,"root",r,"data",n.node(e),r),d.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==r,"node!==clusterId",a!==e));const o=n.edges(a);d.debug("Copying Edges",o),o.forEach((a=>{d.info("Edge",a);const i=n.edge(a.v,a.w,a.name);d.info("Edge data",i,r);try{k(a,r)?(d.info("Copying as ",a.v,a.w,i,a.name),t.setEdge(a.v,a.w,i,a.name),d.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):d.info("Skipping copy of edge ",a.v,"--\x3e",a.w," rootId: ",r," clusterId:",e)}catch(o){d.error(o)}}))}d.debug("Removing node",a),n.removeNode(a)}))}),"copy"),P=t(((e,n)=>{const t=n.children(e);let r=[...t];for(const a of t)I.set(a,e),r=[...r,...P(a,n)];return r}),"extractDescendants"),B=t(((e,n,t)=>{const r=e.edges().filter((e=>e.v===n||e.w===n)),a=e.edges().filter((e=>e.v===t||e.w===t)),i=r.map((e=>({v:e.v===n?t:e.v,w:e.w===n?n:e.w}))),o=a.map((e=>({v:e.v,w:e.w})));return i.filter((e=>o.some((n=>e.v===n.v&&e.w===n.w))))}),"findCommonEdges"),J=t(((e,n,t)=>{const r=n.children(e);if(d.trace("Searching children of id ",e,r),r.length<1)return e;let a;for(const i of r){const e=J(i,n,t),r=B(n,t,e);if(e){if(!(r.length>0))return e;a=e}}return a}),"findNonClusterChild"),A=t((e=>S.has(e)&&S.get(e).externalConnections&&S.has(e)?S.get(e).id:e),"getAnchorId"),T=t(((e,t)=>{if(!e||t>10)d.debug("Opting out, no graph ");else{d.debug("Opting in, graph "),e.nodes().forEach((function(n){e.children(n).length>0&&(d.warn("Cluster identified",n," Replacement id in edges: ",J(n,e,n)),x.set(n,P(n,e)),S.set(n,{id:J(n,e,n),clusterData:e.node(n)}))})),e.nodes().forEach((function(n){const t=e.children(n),r=e.edges();t.length>0?(d.debug("Cluster identified",n,x),r.forEach((e=>{O(e.v,n)^O(e.w,n)&&(d.warn("Edge: ",e," leaves cluster ",n),d.warn("Descendants of XXX ",n,": ",x.get(n)),S.get(n).externalConnections=!0)}))):d.debug("Not a cluster ",n,x)}));for(let n of S.keys()){const t=S.get(n).id,r=e.parent(t);r!==n&&S.has(r)&&!S.get(r).externalConnections&&(S.get(n).id=r)}e.edges().forEach((function(n){const t=e.edge(n);d.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),d.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let r=n.v,a=n.w;if(d.warn("Fix XXX",S,"ids:",n.v,n.w,"Translating: ",S.get(n.v)," --- ",S.get(n.w)),S.get(n.v)||S.get(n.w)){if(d.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),r=A(n.v),a=A(n.w),e.removeEdge(n.v,n.w,n.name),r!==n.v){const a=e.parent(r);S.get(a).externalConnections=!0,t.fromCluster=n.v}if(a!==n.w){const r=e.parent(a);S.get(r).externalConnections=!0,t.toCluster=n.w}d.warn("Fix Replacing with XXX",r,a,n.name),e.setEdge(r,a,t,n.name)}})),d.warn("Adjusted Graph",n(e)),j(e,0),d.trace(S)}}),"adjustClustersAndEdges"),j=t(((e,t)=>{if(d.warn("extractor - ",t,n(e),e.children("D")),t>10)return void d.error("Bailing out");let r=e.nodes(),a=!1;for(const n of r){const t=e.children(n);a=a||t.length>0}if(a){d.debug("Nodes = ",r,t);for(const a of r)if(d.debug("Extracting node",a,S,S.has(a)&&!S.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",t),S.has(a))if(!S.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){d.warn("Cluster without external connections, without a parent and with children",a,t);let r="TB"===e.graph().rankdir?"LR":"TB";S.get(a)?.clusterData?.dir&&(r=S.get(a).clusterData.dir,d.warn("Fixing dir",S.get(a).clusterData.dir,r));const i=new y({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel((function(){return{}}));d.warn("Old graph before copy",n(e)),G(a,e,i,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:S.get(a).clusterData,label:S.get(a).label,graph:i}),d.warn("New graph after copy node: (",a,")",n(i)),d.debug("Old graph after copy",n(e))}else d.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!S.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),t),d.debug(S);else d.debug("Not a cluster",a,t);r=e.nodes(),d.warn("New list of nodes",r);for(const n of r){const r=e.node(n);d.warn(" Now next level",n,r),r?.clusterNode&&j(r.graph,t+1)}}else d.debug("Done, no node has children",e.nodes())}),"extractor"),R=t(((e,n)=>{if(0===n.length)return[];let t=Object.assign([],n);return n.forEach((n=>{const r=e.children(n),a=R(e,r);t=[...t,...a]})),t}),"sorter"),F=t((e=>R(e,e.children())),"sortNodesByHierarchy"),L=t((async(e,r,a,i,o,s)=>{d.warn("Graph in recursive render:XAX",n(r),o);const y=r.graph().rankdir;d.trace("Dir in recursive render - dir:",y);const X=e.insert("g").attr("class","root");r.nodes()?d.info("Recursive render XXX",r.nodes()):d.info("No nodes found for",r),r.edges().length>0&&d.info("Recursive edges",r.edge(r.edges()[0]));const E=X.insert("g").attr("class","clusters"),N=X.insert("g").attr("class","edgePaths"),b=X.insert("g").attr("class","edgeLabels"),C=X.insert("g").attr("class","nodes");await Promise.all(r.nodes().map((async function(e){const n=r.node(e);if(void 0!==o){const n=JSON.parse(JSON.stringify(o.clusterData));d.trace("Setting data for parent cluster XXX\n Node.id = ",e,"\n data=",n.height,"\nParent cluster",o.height),r.setNode(o.id,n),r.parent(e)||(d.trace("Setting parent",e,o.id),r.setParent(e,o.id,n))}if(d.info("(Insert) Node XXX"+e+": "+JSON.stringify(r.node(e))),n?.clusterNode){d.info("Cluster identified XBX",e,n.width,r.node(e));const{ranksep:t,nodesep:o}=r.graph();n.graph.setGraph({...n.graph.graph(),ranksep:t+25,nodesep:o});const l=await L(C,n.graph,a,i,r.node(e),s),f=l.elem;c(n,f),n.diff=l.diff||0,d.info("New compound node after recursive render XAX",e,"width",n.width,"height",n.height),g(f,n)}else r.children(e).length>0?(d.trace("Cluster - the non recursive path XBX",e,n.id,n,n.width,"Graph:",r),d.trace(J(n.id,r)),S.set(n.id,{id:J(n.id,r),node:n})):(d.trace("Node - the non recursive path XAX",e,C,r.node(e),y),await l(C,r.node(e),{config:s,dir:y}))})));const x=t((async()=>{const e=r.edges().map((async function(e){const n=r.edge(e.v,e.w,e.name);d.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),d.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(r.edge(e))),d.info("Fix",S,"ids:",e.v,e.w,"Translating: ",S.get(e.v),S.get(e.w)),await v(b,n)}));await Promise.all(e)}),"processEdges");await x(),d.info("Graph before layout:",JSON.stringify(n(r))),d.info("############################################# XXX"),d.info("###                Layout                 ### XXX"),d.info("############################################# XXX"),m(r),d.info("Graph after layout:",JSON.stringify(n(r)));let I=0,{subGraphTitleTotalMargin:D}=f(s);return await Promise.all(F(r).map((async function(e){const n=r.node(e);if(d.info("Position XBX => "+e+": ("+n.x,","+n.y,") width: ",n.width," height: ",n.height),n?.clusterNode)n.y+=D,d.info("A tainted cluster node XBX1",e,n.id,n.width,n.height,n.x,n.y,r.parent(e)),S.get(n.id).node=n,h(n);else if(r.children(e).length>0){d.info("A pure cluster node XBX1",e,n.id,n.x,n.y,n.width,n.height,r.parent(e)),n.height+=D,r.node(n.parentId);const t=n?.padding/2||0,a=n?.labelBBox?.height||0,i=a-t||0;d.debug("OffsetY",i,"labelHeight",a,"halfPadding",t),await u(E,n),S.get(n.id).node=n}else{const e=r.node(n.parentId);n.y+=D/2,d.info("A regular node XBX1 - using the padding",n.id,"parent",n.parentId,n.width,n.height,n.x,n.y,"offsetY",n.offsetY,"parent",e,e?.offsetY,n),h(n)}}))),r.edges().forEach((function(e){const n=r.edge(e);d.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n),n),n.points.forEach((e=>e.y+=D/2));const t=r.node(e.v);var o=r.node(e.w);const s=p(N,n,S,a,t,o,i);w(n,s)})),r.nodes().forEach((function(e){const n=r.node(e);d.info(e,n.type,n.diff),n.isGroup&&(I=n.diff)})),d.warn("Returning from recursive render XAX",X,I),{elem:X,diff:I}}),"recursiveRender");e("render",t((async(e,t)=>{const c=new y({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel((function(){return{}})),g=t.select("g");r(g,e.markers,e.type,e.diagramId),a(),i(),o(),D(),e.nodes.forEach((e=>{c.setNode(e.id,{...e}),e.parentId&&c.setParent(e.id,e.parentId)})),d.debug("Edges:",e.edges),e.edges.forEach((e=>{if(e.start===e.end){const n=e.start,t=n+"---"+n+"---1",r=n+"---"+n+"---2",a=c.node(n);c.setNode(t,{domId:t,id:t,parentId:a.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),c.setParent(t,a.parentId),c.setNode(r,{domId:r,id:r,parentId:a.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),c.setParent(r,a.parentId);const i=structuredClone(e),o=structuredClone(e),d=structuredClone(e);i.label="",i.arrowTypeEnd="none",i.id=n+"-cyclic-special-1",o.arrowTypeStart="none",o.arrowTypeEnd="none",o.id=n+"-cyclic-special-mid",d.label="",a.isGroup&&(i.fromCluster=n,d.toCluster=n),d.id=n+"-cyclic-special-2",d.arrowTypeStart="none",c.setEdge(n,t,i,n+"-cyclic-special-0"),c.setEdge(t,r,o,n+"-cyclic-special-1"),c.setEdge(r,n,d,n+"-cyc<lic-special-2")}else c.setEdge(e.start,e.end,{...e},e.id)})),d.warn("Graph at first:",JSON.stringify(n(c))),T(c),d.warn("Graph after XAX:",JSON.stringify(n(c)));const l=s();await L(g,c,e.type,e.diagramId,void 0,l)}),"render"))}}}));
